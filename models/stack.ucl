(i.e. the contents of the stack between S .top and S .bottom remain the same).
MODEL stack
(* type of operations of a Stack *)
typedef optype : enum{POP, PUSH, NOOP};

CONST
d0 : TERM;

MODULE S

INPUT
op : optype;
data : TERM;

VAR
contents : FUNC[1];
top : TERM;
bottom : TERM;
first : TERM;

CONST
i : TERM;
c0 : FUNC[1];
t0 : TERM;
b0 : TERM;

DEFINE
first := contents(top);

ASSIGN

(* top is the index of the element at the top of the stack *)
init[top] := t0;
next[top] := case
	op = POP : pred(top); (* decrement top for POP operation *)
	op = PUSH : succ(top); (* increment top for PUSH operation *)
	default : top;
esac;

(* the index of the bottom of the stack *)
init[bottom] := b0;
next[bottom] := bottom;

(* contents maps an index to itâ€™s content *)
init[contents] := Lambda(i). c0(i); (* start with arbitrary content of each index *)
next[contents] := Lambda(i).
	case
		(op = PUSH) & (i = succ(top)) : data; (* insert data at the top of stack *)
			default : contents(i);
esac;
CONTROL

EXTVAR
op : optype := NOOP;
data : TERM := d0;

STOREVAR
item : TERM;
C0 : FUNC[1];
C1 : FUNC[1];

CONST
i : TERM;

EXEC
(* sequence of operation, a PUSH followed by POP *)
op[0] := PUSH;
op[1] := POP;
data[0] := d0;
C0 := S.contents;
simulate(1);
item := S.first;
simulate(1);
C1 := S.contents;
decide(item = d0);
(* check if the stack contents remain the same after
* a PUSH followed by a POP
*)
decide( ((i <= S.top) & (i >= S.bottom)) => (C0(i) = C1(i)) );